## 프로세스 동기화

### 프로세스 동기화

##### 핵심

- 프로세스 동기화
- 임계 구역, 임계 구역 문제 해결
- 세마포어

<br>

##### 정의

> 여러 프로세스(쓰레드)가 공유하는 자원의 일관성 유지

<br>

##### 목적

- 임계 구역 문제 해결

- 프로세스(쓰레드)의 실행 순서 제어
- Busy wait와 같은 비효율성 제거

<br>

##### 은행 문제

- 입출금 관리 프로그램
- 두 개의 쓰레드
  - Parent : 입금
  - Child : 출금
- 각 쓰레드를 100번씩 실행

<br>

##### 은행문제2 에서 올바른 결과가 나오지 않는 이유

- print() 함수로 인한 시간 지연으로 context swiching 발생 -> balance 갱신X

<br>

##### 임계 구역(Critical Section)

> 공유하는 데이터(변수, 테이블, 파일)를 변경하는 코드 영역

- 임계 구역 문제 해결방법

  - **Mutual exclusion** :  **하나의 쓰레드**만 임계 구역에 진입 가능
  - Progress : 유한 시간내에 임계 구역에 접근하는 쓰레드를 결정

  - Bounded wait :  대기하는 쓰레드는 임계 구역에 **유한 시간 내 진입**

<br>

##### 세마포어(Semaphore)

> 프로세스 동기화를 위한 도구 -> Mutual exclusion, Ordering

- 구조

  - value : number of permits -> 접근 가능한 쓰레드의 개수
  - acquire() : test
    - 프로세스가 임계 구역에 진입 요청
    - value--
    - value < 0 : 현재 임계 구역에서 작업 중인 프로세스가 존재 -> block 처리(Semaphore Queue에서 대기)
  - release() : increment
    - 프로세스가 임계 구역에서 나감
    - value++
    - value <= 0 : 현재 임계 구역에서 작업 중인 프로세스가 없음 -> 대기 중인 프로세스 꺼내서 실행

  - Queue :  block된 프로세스(쓰레드)들이 대기

<br>

**은행 문제 3 : 임계 구역 문제 해결**

**은행 문제 4 :  Ordering - 입금 먼저 실행**

**은행 문제 5: Ordering - 입금->출금->입금->출금->.....**

<br>

### 전통적 동기화 문제

##### Producer-Consumer Problem

> 생산자와 소비자는 중간에 **Buffer**를 통해 데이터 처리

<br>

**Producer-Consumer Problem1 : 동기화x, 임계 구역 문제**

**Producer-Consumer Problem2 : 세마포어 -> Busy waiting 발생**

**Producer-Consumer Problem3 : 세마포어 -> Busy waiting 해결**

<br>

**Readers-Writers Problem**

> DB는 임계 구역, read는 여러번 해도 이상 없음, write한 한 번만 실행 

<br>

##### Deadlock

- Dining Philosopher Problem

  - 철학자 5명, 젓가락 5개

  - 철학자의 행동

    - 식사 : 왼쪽, 오른쪽 젓가락 집음

    - 생각 : 왼쪽, 오른쪽 젓가락 놓음

  - deadlock 발생

    - Dining Philosopher Problem1
    - 철학자가 모두 왼쪽 젓가락을 집었을 때 발생

  - deadlock 해결

    - circular wait를 해결 -> 자원할당도로 파악

    - 해결1 : 짝수번 철학자는 왼쪽 젓가락 부터 홀수번은 오른쪽 부터 집음
    - 해결2 : 오름차순

- Deadlock 발생 조건 4가지(필요조건) -> 4가지 모두 충족해야 deadlock이 발생 가능성 존재

  - Mutual exclusion
  - Hold and wait
  - No preemption
  - circular wait

- Deadlock 처리 방법

  - 방지
    - 4가지 중 하나를 깸
    - Hold and wait나 circular wait를 깨는게 그나마 현실적
  - 회피
    - Deadlock의 발생은 올바르지 않은 자원 할당으로 판단
    - 안전한 할당 : 모든 프로세스가 필요한 자원을 잘 할당받고 반환하여 종료
    - 불완전한 할당 : deadlock발생
  - 검출 및 복구
    - 주기적으로 deadlock 체크 -> overhead
  - 무시
    - deadlock의 발생 가능성이 낮으므로